## k8s

### 解决什么问题

是编排？调度？容器云？还是集群管理？

**着重解决的问题：**运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系



### 设计思想

从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。



### k8s的架构



![](https://gitee.com/sinkhaha/picture/raw/master/img/CICD/F04773ED-3CB1-4057-BE04-A88CE572E024.png)

Kubernetes 项目的架构，由 Master 和 Node 两种节点组成，而这两种角色分别对应着`控制节点`和`计算节点`。



#### Master节点

Master 节点(控制节点)，由3个紧密协作的独立组件组合而成，它们分别是

* kube-apiserver：负责 API 服务

  > 是整个集群的入口，充当集群的网关，接收外部的信号和请求，只提供 REST 操作，并将一些信息更新到 etcd 中，它提供了认证相关的功能，用于判断是否有权限进行操作。

* kube-scheduler：负责调度

  > 是集群的调度器，它会持续的关注集群中未被调度的 Pod ，并根据各种条件，比如资源的可用性，节点的亲和性或者其他的一些限制条件，通过绑定的 API 将 Pod 调度/绑定到 Node 上。

* kube-controller-manager：负责容器的编排

  > 它在后台运行着许多不同的`控制器进程`，用来调节集群的状态。当集群的配置发生变更，控制器就会朝着预期的状态开始工作。

* 整个集群的持久化数据，则由 `kube-apiserver 处理后保存在 Etcd 中`



**Master几个重要的功能**

- 接收：外部的请求和集群内部的通知反馈

- 发布：对集群整体的调度和管理

- 存储：存储

  

#### Node节点(kubelet组件)

```bash
+--------------------------------------------------------+       
| +---------------------+        +---------------------+ |       
| |      kubelet        |        |     kube-proxy      | |       
| |                     |        |                     | |       
| +---------------------+        +---------------------+ |       
| +----------------------------------------------------+ |       
| | Container Runtime (Docker)                         | |       
| | +---------------------+    +---------------------+ | |       
| | |Pod                  |    |Pod                  | | |       
| | | +-----+ +-----+     |    |+-----++-----++-----+| | |       
| | | |C1   | |C2   |     |    ||C1   ||C2   ||C3   || | |       
| | | |     | |     |     |    ||     ||     ||     || | |       
| | | +-----+ +-----+     |    |+-----++-----++-----+| | |       
| | +---------------------+    +---------------------+ | |       
| +----------------------------------------------------+ |       
+--------------------------------------------------------+  
```

Node节点(计算节点)上最核心的部分，则是一个叫作` kubelet 的组件`。



1. kubelet 主要负责`同容器运行时（比如 Docker 项目）打交道`。

> 而这个交互所依赖的，是一个称作 CRI（Container Runtime Interface）的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数

>这也是为何，Kubernetes 项目并不关心你部署的是什么容器运行时、使用的什么技术实现，只要你的这个容器运行时能够运行标准的容器镜像，它就可以通过实现 CRI 接入到 Kubernetes 项目当中。

> 而具体的容器运行时，比如 Docker 项目，则一般通过 OCI 这个容器运行时规范同底层的 Linux 操作系统进行交互，即：把 CRI 请求翻译成对 Linux 操作系统的调用（操作 Linux Namespace 和 Cgroups 等）。

2. kubelet 还通过`gRPC 协议`同一个叫作 Device Plugin 的插件进行交互。

3. kubelet 的另一个重要功能是`调用网络插件`和`存储插件`为容器`配置网络`和`持久化存储`。

> 这两个插件与 kubelet 进行交互的接口，分别是 CNI（Container Networking Interface）和 CSI（Container Storage Interface）



**Kube Proxy**

而每个 Pod 在创建后都会有一个虚拟 IP，K8S 中有一个抽象的概念，叫做 `Service` ，`kube-proxy` 便是提供一种代理的服务，让你可以通过 `Service` 访问到 Pod。



实际的工作原理是在每个 Node 上启动一个 `kube-proxy` 的进程，通过编排 `iptables` 规则来达到此效果。



### k8s项目核心功能全景图

![](https://gitee.com/sinkhaha/picture/raw/master/img/CICD/91110BC1-9B5B-495C-A9EF-14F3250DBC1A.png)





* Deployment：多实例管理器

* Service：作为(一组) Pod 的代理入口，从而代替 Pod 对外暴露一个固定的IP地址和端口以负载均衡的方式访问它
* Secret：一个保存在 Etcd 里的键值对数据（如数据库的用户名和密码）
* Job：描述一次性运行的 Pod（比如，大数据任务）
* DaemonSet：描述每个宿主机上必须且只能运行一个副本的守护进程服务
* CronJob：描述定时任务



**除了应用与应用之间的关系外，应用运行的形态是影响“如何容器化这个应用”的第二个重要因素。**

> 为此，Kubernetes 定义了新的、基于 Pod 改进后的对象。
>
> 
>
> 比如 Job，用来描述一次性运行的 Pod（比如，大数据任务）；
>
> 再比如 DaemonSet，用来描述每个宿主机上必须且只能运行一个副本的守护进程服务；
>
> 又比如 CronJob，则用于描述定时任务等等



**在 Kubernetes 项目中，所推崇的使用方法是“声明式 API”：**

1. 首先，通过一个“编排对象”

   > 比如 Pod、Job、CronJob 等，来描述你试图管理的应用

2. 然后，再为它定义一些“服务对象”

   > 比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能

这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）


